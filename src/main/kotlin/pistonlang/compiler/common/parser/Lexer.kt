package pistonlang.compiler.common.parser

import pistonlang.compiler.common.language.SyntaxType
import pistonlang.compiler.common.parser.nodes.GreenLeaf
import pistonlang.compiler.common.parser.nodes.GreenNode

/**
 * A Lexer for a given grammar
 *
 * It is assumed that it has access to the code it's lexing upon construction
 */
interface Lexer<Type> where Type: SyntaxType {
    /**
     * Lexes a single token starting as [pos]
     * @param pos - the position to start lexing a token from
     * @return a token type of the particular grammar
     * It is assumed that this function does not throw an exception and instead there is
     * a corresponding error token for unexpected situations
     */
    fun lexToken(pos: Int): GreenLeaf<Type>
}


/**
 * Similar to an iterator for tokens, except rather than just having a [Iterator.next] function which
 * yields the current token and moves it forward, it has a separate [current] and a [move] function.
 */
class TokenStream<Type: SyntaxType>(private val lexer: Lexer<Type>, startPos: Int) {
    /**
     * The last-read token
     */
    var current = lexer.lexToken(startPos)
        private set

    private var pos = current.length

    /**
     * Lexes the next token and sets [current] to it
     */
    fun move() {
        current = lexer.lexToken(pos)
        pos += current.length
    }
}

/**
 * An [Iterator] going over all the tokens generated by a [Lexer] for a particular grammar
 */
class TokenIterator<Type: SyntaxType>(lexer: Lexer<Type>, startPos: Int = 0): Iterator<GreenNode<Type>> {
    private val stream = TokenStream(lexer, startPos)
    override fun hasNext() = !stream.current.type.isEOF
    override fun next(): GreenNode<Type> = stream.current.also { stream.move() }
}